private async Task ApplyRateLimit(HttpContext context, ClientRequestIdentity identity, List<RateLimitRule> rules, string methodEndpoint, bool isBurstLimit)
{
    methodEndpoint = char.ToUpper(methodEndpoint[0]) + methodEndpoint.Substring(1);

    if (isBurstLimit)
    {
        string period = "1m";
        var remainingLimits = new ConcurrentDictionary<string, int>();
        var resetTimes = new ConcurrentDictionary<string, string>();
        DateTime commonResetTime;

        var resetCacheKey = $"ResetTime:{identity.ClientId.Split('_')[0]}";

        // Get the cached reset time or set it to the next minute boundary
        var cachedResetTime = await this.counterStore.GetAsync(resetCacheKey, context.RequestAborted);
        commonResetTime = cachedResetTime.HasValue ? cachedResetTime.Value.Timestamp : DateTime.UtcNow.AddMinutes(1);

        if (!cachedResetTime.HasValue)
        {
            await this.counterStore.SetAsync(resetCacheKey, new RateLimitCounter { Timestamp = commonResetTime, Count = 0 }, TimeSpan.FromMinutes(1));
        }

        // Process each rule
        await Task.WhenAll(rules.Select(async rule =>
        {
            var counterId = this.BuildCounterKey1(identity, rule);
            var counter = await this.counterStore.GetAsync(counterId, context.RequestAborted).ConfigureAwait(false);

            counter ??= new RateLimitCounter { Timestamp = commonResetTime, Count = 0 };

            // Check if the current time is greater than or equal to reset time
            if (DateTime.UtcNow >= commonResetTime)
            {
                counter = new RateLimitCounter
                {
                    Timestamp = DateTime.UtcNow.AddMinutes(1).AddSeconds(-DateTime.UtcNow.Second), // Align with next minute
                    Count = 0,
                };

                await this.counterStore.SetAsync(counterId, counter, TimeSpan.FromMinutes(1));
            }
            else
            {
                counter = new RateLimitCounter
                {
                    Timestamp = counter.Timestamp,
                    Count = counter.Count + 1,
                };

                await this.counterStore.SetAsync(counterId, counter, TimeSpan.FromMinutes(1));
            }

            double remaining = rule.Limit - counter.Count;
            resetTimes[rule.Endpoint] = commonResetTime.ToString("o");
            remainingLimits[rule.Endpoint] = (int)Math.Max(0, remaining);

            if (string.Equals(rule.Endpoint, methodEndpoint, StringComparison.OrdinalIgnoreCase))
            {
                period = rule.Period;
            }
        }));

        // Add main rule if not already present in resetTimes
        if (!resetTimes.ContainsKey(methodEndpoint))
        {
            var mainRule = rules.FirstOrDefault(r => r.Endpoint == methodEndpoint);
            if (mainRule != null)
            {
                var mainCounterId = this.BuildCounterKey1(identity, mainRule);
                var mainCounter = await this.counterStore.GetAsync(mainCounterId, context.RequestAborted).ConfigureAwait(false);

                mainCounter ??= new RateLimitCounter { Timestamp = commonResetTime, Count = 0 };

                resetTimes[methodEndpoint] = mainCounter.Timestamp.ToString("o");
                remainingLimits[methodEndpoint] = (int)Math.Max(0, mainRule.Limit - mainCounter.Count);
            }
        }

        // Add headers
        const string headerLimit = "X-Burst-Limit-Limit";
        const string headerRemaining = "X-Burst-Limit-Remaining";
        const string headerReset = "X-Burst-Limit-Reset";

        this.AddHeader(headerLimit, period);
        this.AddHeader(headerRemaining, string.Join(", ", remainingLimits.Select(kv => $"{kv.Key}={kv.Value}")));
        this.AddHeader(headerReset, string.Join(", ", resetTimes.Select(kv => $"{kv.Key}={kv.Value}")));
    }
}